#system-design-v2 #design-patterns #structural-design-pattern 

## Glossary
- Bridge design pattern is used to **decouple an abstraction(high-level logic) from its implementation(low-level details)** so that both can evolve independently.
- It is especially useful when you see **class explosion** due to multiple dimensions of variation.

### Problem
Let's consider an example of living things:
```java
public abstract class LivingThings {
	abstract public void breathe();
}

public class Dog extends LivingThings {
	@Override
	public void breathe() {
		System.out.println("Dog: Breathes through its nose; " + 
		"Lives on land; " + 
		"Respiratory system: 2 lungs");
	}
}

public class Fish extends LivingThings {
	@Override
	public void breathe() {
		System.out.println("Fish: Breathes through gills; " +
		"Lives in water; " + 
		"Respiratory system: 2 gills");
	}
}

public class Tree extends LivingThings {
	@Override
	public void breathe() {
		System.out.println("Tree: Breathes through leaves; " + 
		"Lives on land; " +
		"Respiratory system: Leaves");
	}
}

public class Tree extends LivingThings {
	@Override
	public void breathe() {
		System.out.println("Whale: Breathes through lungs; " +
		"Lives in water; " + 
		"Respiratory system: 2 lungs");
	}
}
```

**Problem**:
Both Dog and Whale breathe through lungs - Breathing logic is tied to each animal class. You canâ€™t easily reuse breathing behavior for another animal

### Solution
- Create separate breathing strategies (LungBreathing, GillBreathing, SkinBreathing)
- Then create Living Things (Dog, Fish, Whale, Tree) which selects the breathing strategies

### General UML Class Diagram
![[UML Class Diagram for Bridge Design Pattern.png|950]]
### Code
```java
// Step 1: Implementor Interface
public interface BreathingProcess {
    void breathe();
}

// Step 2: Concrete Implementors
public class GillBreathing implements BreathingProcess {
    @Override
    public void breathe() {
        System.out.println("Breathing through gills.");
    }
}

public class LungBreathing implements BreathingProcess {
    @Override
    public void breathe() {
        System.out.println("Breathing through lungs.");
    }
}

public class PhotosynthesisBreathing implements BreathingProcess {
    @Override
    public void breathe() {
        System.out.println(
            "Breathing through photosynthesis. Releases oxygen through leaves."
        );
    }
}

// Step 3: Abstraction
public abstract class LivingThing {

    protected BreathingProcess breathingProcess;

    // Bridge between LivingThing and BreathingProcess
    public LivingThing(BreathingProcess breathingProcess) {
        this.breathingProcess = breathingProcess;
    }

    public abstract void breathe();
}

// Step 4: Refined Abstractions
public class Dog extends LivingThing {

    public Dog(BreathingProcess breathingProcess) {
        super(breathingProcess);
    }

    @Override
    public void breathe() {
        System.out.print("Dog: ");
        breathingProcess.breathe();
    }
}

public class Fish extends LivingThing {

    public Fish(BreathingProcess breathingProcess) {
        super(breathingProcess);
    }

    @Override
    public void breathe() {
        System.out.print("Fish: ");
        breathingProcess.breathe();
    }
}

public class Tree extends LivingThing {

    public Tree(BreathingProcess breathingProcess) {
        super(breathingProcess);
    }

    @Override
    public void breathe() {
        System.out.print("Tree: ");
        breathingProcess.breathe();
    }
}

```
### Bridge Pattern vs Strategy Pattern
The patterns are mostly similar but differ in the intent:
- **Bridge**: Focuses on handling two hierarchies independently (abstraction & implementation). Like a LivingThings (abstraction) that has different Respiratory Mechanisms (implementation). LivingThings and Respiratory Mechanisms evolve independently.
- **Strategy**: Focuses on handling different behaviors dynamically (at runtime). Like choosing the driving route on Google Maps, you can switch between "fastest", "shortest", or "avoid tolls" at runtime.

---
Bridge and Strategy look very similar in code, but they differ in intent and axis of change, not syntax. The UML is generic Bridge; your breathing example can look like Strategy, depending on how you explain it.

Why the UML feels different from your code
- The UML you shared is the canonical Bridge pattern:
	- Abstraction â†’ what the client works with
	- Implementor â†’ how the work is done

Both hierarchies evolve independently

##### Key idea:
> â€œDecouple abstraction from implementation so both can vary independently.â€

Thatâ€™s why the UML shows two inheritance trees:
- Abstraction â†’ RefinedAbstraction
- Implementor â†’ ConcreteImplementor(s)

###### Why your code looks like Strategy
Your BreathingProcess: `LivingThing has-a BreathingProcess`
This is exactly how Strategy is implemented.

Strategy definition:
> â€œDefine a family of algorithms, encapsulate them, and make them interchangeable.â€

Breathing is an algorithm, so your brain correctly maps it to Strategy.

#### The real difference (this is the key)
Strategy
- Focus: behavior selection
- Client usually chooses or switches strategies
- Abstraction hierarchy is often flat
- Example:
	- â€œThis animal can change how it breathes at runtime.â€

Bridge
- Focus: structural decoupling
- Two independent dimensions grow over time
- Neither hierarchy dominates the other
- Example:
	- â€œWe will keep adding new LivingThings and new Breathing mechanisms, independently.â€

###### Why Bridge often looks like Strategy

Because:
- Both use composition
- Both use interfaces
- Both delegate work

ğŸ‘‰ Pattern intent is not visible in UML alone
You must read it as a design decision, not just code structure.

Practical rule (exam-friendly)
- If the question says â€œvary independentlyâ€ â†’ Bridge
- If it says â€œreplace behaviorâ€ â†’ Strategy

Your instinct is correct â€” the boundary is subtle, and many examples sit right on it.