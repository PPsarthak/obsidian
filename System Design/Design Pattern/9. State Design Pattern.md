#system-design-v2 #design-patterns #behavioral-design-pattern 

> State Pattern lets an object change its behavior dynamically by delegating behavior to state-specific classes instead of using conditionals.
## Glossary
- Object changes behavior after performing some operation i.e., set of action depends on the current state
- *Instead of using conditionals (if / switch), behavior is delegated to state objects*
- State Design Pattern allows the object to change it behavior at runtime when there is internal state change


<span style="color:rgb(255, 215, 158)">Key Components</span> 
- Context â€“ The main object whose<span style="color:rgb(106, 240, 214)"></span> behavior changes
- State Interface â€“ Declares all possible actions
- Concrete States â€“ Implement behavior for each state

Let's take an example of **Traffic Signal**
- It has 3 states: Red Signal, Yellow Signal, Green Signal
- Each state performs some behavior and once done, moves to the next state automatically (assumption)

### UML Class Diagram

![[UML Class Diagram for State Design Pattern.png|850]]
### Code
```java
public interface SignalState {
	void action(TrafficLight signal);
}

public class RedSignalState implements SignalState {
	@Override
	public void action(SignalState signal) {
		//some logic like - keep signal red for 60 secs
		System.out.println("RED: Stop traffic for 60 seconds");
		signal.setState(new GreenSignalState());  //then perhaps set the next state to green
	}
}

public class GreenSignalState implements SignalState {
	@Override
	public void action(SignalState signal) {
		//some logic like - keep signal green for 30 secs
		System.out.println("GREEN: Allow traffic for 30 seconds");
		signal.setState(new YellowSignalState());
	}
}


public class YellowSignalState implements SignalState {
	@Override
	public void action(SignalState signal) {
		//some logic like - keep signal yellow for 10 secs
		System.out.println("YELLOW: Prepare to stop within 10 seconds");
		signal.setState(new RedSignalState());
	}
}

public class TrafficSignal {
	private SignalState state;  //assume we have getState() and setState() 
	
	public TrafficSignal() {
		this.state = new RedSignalState();  //initial state
	}
	
	public void change() {
		state.action(this);
	}
}


public class Client {
	public static void main(String[] args) {
		TrafficSignal signal = new TrafficSignal();

		signal.change(); // RED â†’ GREEN
		signal.change(); // GREEN â†’ YELLOW
		signal.change(); // YELLOW â†’ RED
	}
}
```

#### Common Follow-Up Questions (Be Ready)
1. State vs Strategy â†’ Strategy is chosen by client, State is chosen by context
	 
	 **Strategy Pattern** 
	- <span style="color:rgb(240, 81, 105)">encapsulate interchangeable algorithms and let the client choose which one to use</span> (choice happens outside the object)
	- *The object itself is usually unaware why a strategy was chosen*
	
	**State Pattern**
	- <span style="color:rgb(240, 81, 105)">allows an object to change its behavior when its internal state changes</span> (choice happens inside the object)
	- *The objectitself is aware + (might be) used to change the state* 
	
	ðŸ“Œ Interview golden line:
	> State pattern is Strategy with enforced transitions and lifecycle semantics.
	> If behavior changes because the user chose something â†’ Strategy
	> If behavior changes because the objectâ€™s state changed â†’ State
	
1. Where do transitions happen? â†’ Inside state classes
2. Can state be immutable? â†’ Yes, often stateless singletons