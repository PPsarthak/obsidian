#system-design-v2  #design-patterns 

#### Let’s cut through that and look at the clean, OCP-compliant approach that actually deserves to be called a Factory.

The real problem Factory solves
> “I want to create objects, but I don’t want to change existing code when a new type is added.”

```java
public interface Payment {
    void pay();
}

public class CardPayment implements Payment {
    @Override
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using Card");
    }
}


public class UpiPayment implements Payment {
    @Override
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using UPI");
    }
}

```

**Factory Classes**
```java
public interface PaymentFactory {
    Payment create();
}

public class CardPaymentFactory implements PaymentFactory {
    @Override
    public Payment create() {
        return new CardPayment();
    }
}

public class UpiPaymentFactory implements PaymentFactory {
    @Override
    public Payment create() {
        return new UpiPayment();
    }
}

```

**Factory Registry**
```java
public class PaymentFactoryRegistry {

    private final Map<String, PaymentFactory> factoryMap;
    
    public Payment createPayment(String type) {
        PaymentFactory factory = factoryMap.get(type);

        if (factory == null) {
            throw new IllegalArgumentException("Unsupported payment type: " + type);
        }

        return factory.create();
    }
    
    public void addPayment(String payment, PaymentFactory factory) {
	    factoryMap.put(payment, factory);
    }
}
```

### What Abstract Factory really is
Abstract Factory enables to create a family of related objects

What problem it solves (the real one)

When:
- Objects are related and must be used together
- You want to switch entire variants (not just one object)

```java
public class CardPaymentSuiteFactory implements PaymentSuiteFactory {
    public Payment createPayment() { return new CardPayment(); }
    public Validator createValidator() { return new CardValidator(); }
    public FeeCalculator createFeeCalculator() { return new CardFeeCalculator(); }
}

public class UpiPaymentSuiteFactory implements PaymentSuiteFactory {
    public Payment createPayment() { return new UpiPayment(); }
    public Validator createValidator() { return new UpiValidator(); }
    public FeeCalculator createFeeCalculator() { return new UpiFeeCalculator(); }
}

```


Strong mental model (remember this)
> Factory Method chooses a class.
> Abstract Factory chooses a world.