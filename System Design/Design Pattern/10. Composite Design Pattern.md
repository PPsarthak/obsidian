#system-design-v2 #design-patterns #structural-design-pattern 

> Composite pattern lets clients treat individual objects and compositions of those individual objects uniformly

## Glossary
- Compose objects into tree structures to represent part–whole hierarchies and let clients treat individual objects and compositions uniformly.

**Example**:
A File System
- A File System either contains a file or a directory - which itself can again contain file or a directory
- Client should be able to perform operations like - see size, see date created, etc. on file and directory uniformly

Normally, if you write client code, you need to know whether it is a `File` or a `Directory` before calling methods.
```java
public void printContents() {
	 System.out.println("Directory Name: " + directoryName);
	 for (Object obj: objectList) {
		 if (obj instanceof File) {
			 ((File) obj).printContents();
		} else if (obj instanceof Directory) {
			((Directory) obj).printContents();
		}
	}
}
```

*This breaks the Open/Closed Principle* 
If we want to add a new file type, we need to modify this method to add another if/else condition (which is messy).

**Solution**
- Both `File` and `Directory` implement the same Component interface.
- Client code doesn’t have to know whether it’s a file or a folder, and hence it can treat both as composite and perform operations uniformly(advantage of using abstraction).

### UML Class Diagram
![[UML Class Diagram for Composite Design Pattern.png|850]]

### Code
```java
public interface FileSystemComponent {
	void printContents();
}

public class File implements FileSystemComponent {
	String fileName;

	public File(String name) {
		this.fileName = name;
	}

	@Override
	public void printContents() {
		System.out.println("File name: " + fileName);
	}
}

public class Directory implements FileSystemComponent {
	String directoryName;
	List<FileSystemComponent> children;
	
	public Directory(String name) {
		this.directoryName = name;
		children = new ArrayList<>();
	}
	
	//optional methods
	public void add(FileSystemComponent fileSystemComponent) {
		children.add(fileSystemComponent);
	}
	
	//optional methods
	public void remove(FileSystemComponent fileSystemComponent) {
		children.remove(fileSystemComponent);
	}
	
	@Override
	public void printContents() {
		System.out.println("Directory Name: " + directoryName);
		for (FileSystemComponent child : children) {
			child.printContents();
		}
	}
}
```