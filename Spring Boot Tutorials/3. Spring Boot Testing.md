---
status: Done
last-reviewed: 2025-08-30
tags:
  - spring-boot
  - testing
---
#placement-preparation #spring-boot #testing
### üîçWhy write tests?
Writing tests is essential for building robust, maintainable, and reliable applications. 
##### Benefits of Testing
- Catch Bugs Early  
    Detect issues before they reach production.
- Improve Code Quality  
    Encourages cleaner, modular, and testable code.
- Safe Refactoring  
    Confidently make changes knowing tests will catch regressions.
- Faster Development  
    Reduces time spent on manual verification and debugging.
- Better Documentation  
    Tests demonstrate how the code is expected to behave.
- Supports CI/CD Pipelines  
    Automated tests are crucial in modern CI/CD pipelines to ensure quality and prevent broken builds.
### Types of Tests
##### üß™ Unit Tests - `@Test`
- Test **individual classes/methods in isolation** (typically service or utility classes).
- Use `@Test` to run unit tests
- Use Mockito to mock dependencies.
##### üß© Integration Tests - `@SpringBootTest`
- Test the **interaction between multiple components** (e.g., services, repositories, controllers).
- May involve real DB (like H2) or external APIs.
##### üåê Web Layer (Slice) Tests - `@WebMvcTest` or `@DataJpaTest`
- Use to test specific **application layers only**.
- Fast alternative to full integration tests.
##### üîÅ End-to-End (E2E) / System Tests
- Test the **entire application flow from request to response**.
- Simulate real user behavior (via HTTP clients, Selenium, etc.)

> The¬†[spring-boot-starter-test](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test)¬†is the primary dependency that contains the majority of elements required for our tests and is included with **JUnit**, **Mockito**, and **Assertion** libraries by default in all Spring Boot projects

---
### Testing in Spring Boot

#### üî∂Overview of libraries used
- **JUnit** is used test each individual unit/component of application in isolation
- **Assertions** check whether the actual output of code matches the expected result.
- **Mockito** is used to simulate the behavior of dependencies

### JUnit
##### üè∑Ô∏è Key Annotations - JUnit
```java
@Test            // Marks a method as a test case
@Disabled         // Marks the test method/class as disabled 
@BeforeEach      // Runs before each test method
@AfterEach       // Runs after each test method
@BeforeAll       // Runs once before all tests
@AfterAll        // Runs once after all tests
```

> [!tip]+ **Flow of Execution**  
> `@BeforeAll` ‚Üí `@BeforeEach` ‚Üí `@Test` ‚Üí `@AfterEach` ‚Üí `@AfterAll`  
> üõ†Ô∏è SETUP ‚Üí ‚úÖ TEST ‚Üí üßπ CLEANUP
>   
>  So, If a test class contains 5 test methods:
>  `@BeforeAll` and `@AfterAll` run **once**
>  `@BeforeEach` and `@AfterEach` run **5 times**
---
#### Common JUnit Assertions

| **Method**                                       | **Description**                                            |
| -------------------------------------------- | ------------------------------------------------------ |
| `assertEquals() / assertNotEquals()`         | Checks if both arguments are equal/not equal           |
| `assertTrue() / assertFalse()`               | Passes if argument is true/false                       |
| `assertNull() / assertNotNull()`             | Passes if argument is null/not null                    |
| `assertSame() / assertNotSame()`             | Passes if both argument refer to same/different object |
| `assertArrayEquals()`                        | Passes if both argument arrays are equal               |
| `assertThrows(Exception.class, () -> {...})` | Passes if exception is thrown                          |
#### @ParameterizedTest in JUnit 5
A parameterized test is a test that runs multiple times with different input values.
Instead of writing multiple test methods for different inputs, you can reuse the same test logic with varying parameters.
###### Why Use It?
- Avoids duplicate test code.
- Makes tests more readable and data-driven.
- Great for boundary testing and input validation scenarios.

```java
@Test
void testIsEven_with2() {
    assertTrue(NumberUtils.isEven(2));
}

@Test
void testIsEven_with4() {
    assertTrue(NumberUtils.isEven(4));
}

@Test
void testIsEven_with6() {
    assertTrue(NumberUtils.isEven(6));
}

//Instead of this, you can do - 
@ParameterizedTest
@ValueSource(ints = {2, 4, 6, 8})
void testIsEven(int number) {
    assertTrue(NumberUtils.isEven(number));
}
```
##### Sources of Parameters
JUnit 5 provides multiple sources for feeding values:
1. `@ValueSource`
	For primitive or simple types - 
	```java
	@ParameterizedTest
	@ValueSource(strings = {"racecar", "radar", "level"})
	void testPalindrome(String word) {
	    assertTrue(StringUtils.isPalindrome(word));
	}
	```

2. `@EnumSource`
	For testing all or selected enums:
	```java
	@ParameterizedTest
	@EnumSource(DayOfWeek.class)
	void testEnumValues(DayOfWeek day) {
	    assertNotNull(day);
	}
	```
3. `@CsvSource`/ `@CsvFileSource`
	For multiple arguments 
	```java
	@ParameterizedTest
	@CsvSource({
	    "2, true",
	    "3, false",
	    "10, true"
	})
	void testIsEven(int number, boolean expected) {
	    assertEquals(expected, NumberUtils.isEven(number));
	}
	
	@ParameterizedTest
	@CsvFileSource(resources = "/numbers.csv", numLinesToSkip = 1)
	void testFromFile(int number, boolean expected) {
	    assertEquals(expected, NumberUtils.isEven(number));
	}
	```
#### Test Suite in JUnit
A test suite is simply a way to group multiple test classes together and run them as a single unit.
This is useful when you want to:
- Run all tests in the project.
- Run only a specific group of tests (e.g., ‚Äúcontroller tests‚Äù or ‚Äúintegration tests‚Äù).
- Organize tests logically for better CI/CD pipelines.
##### Annotations for Suites in JUnit 5
1. `@Suite`
	- Marks the class as a suite.
2. `@SelectClasses`
	- Explicitly include certain test classes.
3. `@SelectPackages`
	- Run all test classes under a package.
4. `@IncludeClassNamePatterns / @ExcludeClassNamePatterns`
	- Filter which test classes to include/exclude using regex.
5. `@IncludeTags / @ExcludeTags`
	- Useful when you organize tests with @Tag

Example - 
```java
@Suite
@SelectClasses({UserControllerTest.class, UserServiceTest.class})
@SelectPackages("com.example.project.repository")
public class ApplicationTestSuite {
}
```
üëâ This suite will run:
- `UserControllerTest`
- `UserServiceTest`
- All test classes under `com.example.project.repository` package
---
### Mockito
##### üß© Mockito Components:
- `Mock` ‚Üí Fake object that simulates behavior.
- `Stub` ‚Üí Predefined behavior of a mock.
- `Spy` ‚Üí Partial mock with real methods + mock behavior

##### üß™@Mock vs @MockBean vs @SpyBean

`@Mock` - - Creates a mock object (a fake implementation) using pure Mockito and does not involve Spring
`@MockBean` - - Replaces an existing Spring bean in the application context with a Mockito mock (`@SpringBootTest` or `@WebMvcTest`) (used in Controller Testing) [[#^Mock-Bean-For-Controller-Testing]]
`@SpyBean` -- Injects a spy (partial mock) into the Spring context

| Annotation  | Spring Context Required | Real Logic Runs?       | Use Case                            |
| ----------- | ----------------------- | ---------------------- | ----------------------------------- |
| `@Mock`     | ‚ùå No                    | ‚ùå No                   | Pure unit tests with Mockito        |
| `@MockBean` | ‚úÖ Yes                   | ‚ùå No                   | Replace Spring beans in tests       |
| `@SpyBean`  | ‚úÖ Yes                   | ‚úÖ Yes (unless stubbed) | Override parts of real Spring beans |
##### üè∑Ô∏è Key Annotations - Mockito
```java
@ExtendWith(MockitoExtension.class)    //All classes using Mockito must have this annotation
@Mock           // Declares a mock object
@InjectMocks    // Injects the declared mocks into the class under test
@Spy            // Real methods are called unless they are explicitly stubbed
```

> [!example]+ **Example: Mock Injection**  
> Testing `UserService` (which depends on `UserRepository`)  
> In `UserServiceTest`:
> ```java
> @Mock UserRepository userRepo; 
> @InjectMocks UserService userService;
> ```
> üëâ The `userRepo` mock is injected into `userService`.

> [!tip] Initialize mocks
> `@BeforeEach` + `MockitoAnnotations.openMocks(this)`
##### üí° Common Methods for Stubbing:
```java
when(dependency.method()).thenReturn(obj);         // Define behavior
verify(dependency, times(1)).method();             // Verify invocation
doNothing().when(dependency).method();             // Mock void method
```
---
#### üîê Testing Private Methods
##### Java Reflections
Since private methods are not accessible directly through class/object, we can use **Java Reflections** to test these methods.

Say, we have a private method (helper method) - 
```Java
private boolean validateUserId(User userObj){
	return user!=null && user.getId()!=null;
}
```

üß™ Access & Invoke in Test: (Assume we already have `userService` and `userObj` object created) 
```Java
// the args to getDeclaredMethod() is the name of the method, followed by ...args to the method -  so here it is User.class
Method validateUserIdMethod = UserService.class.getDeclaredMethod("validateUserId", User.class);
validateUserIdMethod.setAccessible(true);
boolean methodResponse = (boolean) validateUserIdMethod.invoke(userService, `...args` userObj);
```

> [!tip] Java Reflections is not a good practice
> First of all, a private method should only contain logic that is internal to the class - typically small, supportive operations.
> If the method encapsulates important business logic, then you should reconsider using the "private" access modifier for such method
> Secondly, and most importantly, using Java Reflection to make the **private method accessible breaks encapsulation**
##### Power Mockito
Power Mockito is an extension of Mockito that **allows you to mock things Mockito normally cannot** and *can actually mock private methods* by intercepting calls at runtime (using bytecode manipulation aka class loading tricks)
It can mock - 
- Static methods - stub static utilities (like `UUID.randomUUID()` or `LocalDate.now()`)
- Final classes / final methods 
- Private methods
- Constructors (new object creation inside methods)
###### Using Power Mockito to test private methods
```java
import org.junit.Test;
import org.junit.runner.RunWith;
import static org.junit.Assert.*;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;

@RunWith(PowerMockRunner.class)
@PrepareForTest(UserService.class)
public class UserServiceTest {

    @Test
    public void testValidateUserId_directPrivateCall() throws Exception {
        UserService userService = new UserService();

        // Call private method directly with PowerMockito - here we are not mocking, we are actually invoking the method
        boolean result1 = PowerMockito.invokeMethod(userService, "validateUserId", (User) null);
        assertFalse(result1);

        boolean result2 = PowerMockito.invokeMethod(userService, "validateUserId", new User(null));
        assertFalse(result2);

        boolean result3 = PowerMockito.invokeMethod(userService, "validateUserId", new User("123"));
        assertTrue(result3);
    }
}
```
###### Using Power Mockito to mock private methods
Let's assume the following example - 
```java
public class UserService {
    public String process(User user) {
        if (validateUserId(user)) {
            return "Valid User";
        }
        return "Invalid User";
    }

    private boolean validateUserId(User userObj) {
        return userObj != null && userObj.getId() != null;
    }
}
```

Now to mock the private method - 
```java
@RunWith(PowerMockRunner.class)
@PrepareForTest(UserService.class)
public class UserServiceTest {

    @Test
    public void testProcess_withMockedPrivateMethod() throws Exception {
        // Create a spy of UserService (so we can partially mock)
        UserService userService = PowerMockito.spy(new UserService());

        // Mock private method validateUserId to always return true
        PowerMockito.doReturn(true).when(userService, "validateUserId", ArgumentMatchers.any(User.class));

        // Call public method that internally calls the private method
        String result = userService.process(new User("123"));

        assertEquals("Valid User", result);
    }
}
```
###### üìå Key Points
- `@PrepareForTest(UserService.class)` ‚Üí tells Power Mockito to prepare bytecode manipulation for that class.
- `PowerMockito.spy(...)` ‚Üí allows partial mocking (real object + mocked private method).
- `doReturn(...).when(object, "methodName", args...) `‚Üí used to mock private method.
- You don‚Äôt call the private method directly; you test it indirectly through the public method (process)
###### üëâ General best practice:
- <mark style="background: #FF6699;">Don‚Äôt test private methods directly.</mark> Instead, test the public methods that use them.
- If you find yourself needing to mock private methods, it‚Äôs usually a design smell ‚Üí maybe split that logic into a separate class/service.
#### Testing Controller Layer - `MockMvc`
When testing the Controller layer, the goal is to verify:
- HTTP request ‚Üí response mapping.
- Correct status codes, headers, and response body.
- That controller properly interacts with the service layer (often mocked)
###### Flow of Testing
`@WebMvcTest` ‚Üí loads only the web layer (Controller, filters, converters, etc. - minimal Spring MVC infrastructure)
`@MockBean` ‚Üí replaces service dependencies with mocks (so you don‚Äôt hit DB) 
^Mock-Bean-For-Controller-Testing

```java
@WebMvcTest(UserController.class)  
class UserControllerTest {
    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService userService;  // mock service dependency
}
```

You will mock `userService` normally like you had did while testing service layer earlier - 
```java
when(userService.getUserById(1L)).thenReturn(new User(1, "Alice"));
```

The **`MockMvc.perform()`** method simulates an HTTP request. You can build requests using helpers like:
- get("/users/1") ‚Üí GET request
- post("/users") ‚Üí POST request
- put("/users/1") ‚Üí PUT request
- delete("/users/1") ‚Üí DELETE request
```java
mockMvc.perform(get("/users/1")
           .andExpect(status().isOk())  
           .andExpect(jsonPath("$.name").value("Alice"));
```

Here, 
- `andExpect()` is used to perform assertions
- the `$` represents the entire response object - so if you had a list of objects as the response, to fetch the first object you would : `$[0].name`

> [!info]+ How MockMvc works?
> 1. It builds the request using `MockHttpServletRequest` (Spring‚Äôs test implementation of `HttpServletRequest`)
> 2. You can add headers, params, body, content type, etc. just like a normal `HttpServletRequest`
> 3. Then just like a real request, it passes it into Dispatcher Servlet - All filters, interceptors, controllers, exception handlers, view resolvers are invoked ‚Äî same as runtime. But instead of real Tomcat, it‚Äôs all in-memory simulation
> 4. Then the response is not written to a real socket/HTTP stream; instead, it‚Äôs captured into a `MockHttpServletResponse` which lets you assert status codes, headers, and response body easily

For testing POST/PUT requests (requests that have `@RequestBody`), you need to add the `.contentType() and .content()`
```java
mockMvc.perform(post("/users")
            .contentType(MediaType.APPLICATION_JSON)   
            .content("{\"name\": \"Bob\"}"))
           .andExpect(status().isCreated())
           .andExpect(jsonPath("$.id").value(2))
           .andExpect(jsonPath("$.name").value("Bob"));
```
###### Additional Notes
- Use `@WithMockUser` (from Spring Security test) when testing secured endpoints.
- Use `param("key", "value")` for query params.
- Use `.andDo(print()) `to debug and see full request/response in console.

##### Summary Flow
1. Annotate with `@WebMvcTest` (lightweight) or `@SpringBootTest` (full).
2. Inject MockMvc.
3. Mock service dependencies with `@MockBean` (Mockito).
4. Use `mockMvc.perform()` to simulate requests.
5. Assert response with `andExpect()`.
6. Optionally verify service interactions with `Mockito.verify()`.
#### Testing Repository Layer
When testing it, you want to check:
- Entity mapping correctness (annotations, relationships).
- Query methods (findBy‚Ä¶, @Query, native queries).
- CRUD behavior (save, update, delete).

Instead of hitting a real DB, we use H2, an in-memory relational database that spins up quickly and vanishes after tests. Hence here, we use **`@DataJpaTest`** which:
- Configures an in-memory DB (H2 by default).
- Scans only repository-related beans.
- Disables full Spring Boot auto-configuration (faster).
- Provides a `TestEntityManager` for DB operations if needed.

```java
@DataJpaTest
class UserRepositoryTest {

    @Autowired
    private UserRepository userRepository;

    @Test
    void testSaveAndFindUser() {
        User user = new User(null, "Alice");
        User saved = userRepository.save(user);

        assertNotNull(saved.getId());
        assertEquals("Alice", saved.getName());
    }
}
```
### üß± Test Configuration & Profiles in Spring Boot

When writing tests in Spring Boot, it‚Äôs crucial to control the application configuration used during test execution. You don‚Äôt want your tests to connect to production databases, send actual emails, or depend on external services. Instead, you want a lightweight, isolated configuration tailored for testing.
#### @TestPropertySource
The annotation `@TestPropertySource` is used to specify inline properties or external property files for a particular test class.
It is useful when you want to override only a few properties without creating a full application-test.yml.

```java
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb",
    "spring.jpa.hibernate.ddl-auto=create-drop"
})
class ServiceLayerTest {
    @Test
    void contextLoads() {
        // Test with overridden properties
    }
}

//OR instead of specifying each individual property here in annotation, you can create a seperate .properties file and load it 
//This tells Spring to load properties from custom-test.properties in src/test/resources

@TestPropertySource(locations = "classpath:custom-test.properties")
class ServiceLayerTest {
}
```
#### @ActiveProfiles
By default, Spring Boot loads the default profile if no profile is specified. With `@ActiveProfiles`, **you explicitly tell Spring which profile to use for the test**
```java
//This activates the test profile, meaning Spring will load application-test.yml.

@ActiveProfiles("test")
class OrderServiceTest {
}

//You can also use multiple profiles - @ActiveProfiles({"test", "integration"})
```

> [!tip] This is similar to `@TestPropertySource`. 
> Here, you created a `application-test.yml` file and activated the test profile, so now Spring will automatically load the test yaml file. Using `@TestPropertySource`, you would have to just mention the path to this yaml file.
> But the difference between them is - with the annotation, you can also create 1 more yaml file and pass it - and you wouldn't have to follow the standard naming convention of adding "-test" at the end
> 
> But still, use `@TestPropertySource` sparingly - 
> - Ideal for small overrides at the class level.
> - Don‚Äôt abuse it ‚Äî if many overrides are needed, update the YAML instead.
### @TestConfiguration
- Spring Boot provides `@TestConfiguration` as a special annotation for defining test-specific beans that should not leak into your main application context
- It‚Äôs a variant of `@Configuration` which **helps you create mock beans, fake services, or special configs** required only for testing - Example: replace a real Email Service with a no-op fake that just logs
- You (HAVE TO) create it in `src/test/java`
##### Why not just use @Configuration?
If you annotate with `@Configuration` inside your test sources (`src/test/java`), Spring may still scan and load it in the main application context (especially if component scanning picks it up).
- This pollutes your production configuration with test beans.
- `@TestConfiguration` explicitly prevents that ‚Äî it is ignored for normal component scanning and only applied in tests

```java
@TestConfiguration
public class TestBeansConfig {
    @Bean
    public PasswordEncoder passwordEncoder() {
        return NoOpPasswordEncoder.getInstance(); // don‚Äôt hash in tests
    }
}

//Then import it into your test with - @Import()

@Import(TestBeansConfig.class)
class AuthServiceTest {
    @Autowired
    private PasswordEncoder encoder;
}
```
###### Key Differences from Alternatives
- `@MockBean`: replaces beans in the context with Mockito mocks.
- `@TestConfiguration`: gives you full control over bean definitions (real, fake, or mock).

üëâ You often use them together: @TestConfiguration for structural setup + @MockBean for mocking.
### üöÄ @SpringBootTest
- `@SpringBootTest` is used to load the **full Spring application context** for integration testing. In simpler words, it allows us to bootstrap **the entire Spring Boot application in a test environment**.
- It allows you to test how various Spring-managed components/multiple layers (service, repo, etc.) work together

Here, `UserService` is tested with all dependencies wired (like repositories, properties, etc.), meaning it‚Äôs not a unit test but an integration test -
```Java
@SpringBootTest
class UserServiceIntegrationTest {

    @Autowired
    private UserService userService;

    @Test
    void testUserCreation() {
        User user = userService.createUser("Alice");
        assertNotNull(user.getId());
    }
}
```

You can also using mocking if you want, it is always supported - 
```Java
@SpringBootTest
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService userService;

    @Test
    void testGetUser() throws Exception {
        when(userService.getUser(1L)).thenReturn(new User(1L, "Alice"));

        mockMvc.perform(get("/users/1"))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.name").value("Alice"));
    }
}
```


--- THE END ---
### üß± JUnit Basics
- What is JUnit?
- Writing a simple test with `@Test`
- Assertions (`assertEquals`, `assertTrue`, etc.)
- Test lifecycle annotations: `@BeforeEach`, `@AfterEach`, `@BeforeAll`, `@AfterAll`
- Disabling tests: `@Disabled`
### üîß Mockito & Stubbing
- What is Mockito?
- `@Mock`, `@InjectMocks`, `@Spy`
- Defining behavior using `when().thenReturn()`
- Verifying interactions with `verify()`
- Stubbing void methods with `doNothing()`, `doThrow()`
### 4. üîÅ Dependency Injection in Tests
- Using `@MockBean` vs `@Mock` vs `@SpyBean`
- Testing with mocked dependencies in Spring context
### 5. üß™ Spring Boot Testing Annotations
- `@SpringBootTest`
- `@WebMvcTest`
- `@DataJpaTest`
- `@MockBean`
- `@TestConfiguration`
- `@AutoConfigureMockMvc`
### 6. üìÇ Testing Layers Separately
- Testing Service Layer (mocking Repositories)
- Testing Controller Layer (with `MockMvc`)
- Testing Repository Layer (with in-memory DB like H2)
### 7. üì° MockMvc for Controller Testing
- Setup and usage
- Sending GET/POST requests
- Validating responses
### 8. üß± Test Configuration & Profiles
- `@TestPropertySource`
- `application-test.yml`
- `@ActiveProfiles`
### 9. üîÑ Database Testing
- H2 for tests
- Transactional tests (`@Transactional`)
- Cleaning data between tests
### 10. üí• Testing Exception Scenarios
- Expecting exceptions
- Using `assertThrows` and `MockMvc` error assertions
### 11. üîç Advanced: Parameterized and Dynamic Tests
- `@ParameterizedTest`    
- `@CsvSource`, `@MethodSource`, etc.    
### 12. üìä Code Coverage and Best Practices
- Tools like `Jacoco`    
- Structuring test folders
- Naming conventions
---

[^1]  [Code Snippet YouTube Video](https://www.youtube.com/watch?v=XVFqOFKGeGM) 