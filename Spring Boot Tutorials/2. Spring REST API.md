---
status: Done
last-reviewed: 2025-08-27
tags:
  - spring-boot
  - "#REST"
---
#spring-boot #placement-preparation #REST 
##### üåêWhat is a REST API?
Representational State Transfer is an architecture for building web services that communicate over HTTP using standard and generally returns a JSON/XML form of data through methods like -
- *GET* ‚Üí Read data
- *POST* ‚Üí Create data
- *PUT* ‚Üí Update entire resource
- *PATCH* ‚Üí Update partial resource
- *DELETE* ‚Üí Remove data
###### üß± Core Principles of REST
![[REST APIs#^REST-API-Guidelines]]

|                   | **REST**                     | **SOAP**                         | **GraphQL**                        | **gRPC**                         |
| ----------------- | ---------------------------- | -------------------------------- | ---------------------------------- | -------------------------------- |
| *Protocol*        | HTTP                         | HTTP, SMTP, TCP                  | HTTP                               | HTTP/2                           |
| *Data Format*     | JSON, XML                    | XML only                         | JSON                               | Protobuf (binary)                |
| *Message Size*    | Medium                       | Large (verbose)                  | Small (custom fields)              | Very small (efficient)           |
| *Strong Typing*   | ‚ùå Not enforced               | ‚úÖ Yes (WSDL)                     | ‚úÖ Yes (schema-based)               | ‚úÖ Yes (Protobuf contracts)       |
| *Caching Support* | ‚úÖ Yes                        | ‚ùå No                             | ‚ùå No built-in                      | ‚ùå No built-in                    |
| *Ease of Use*     | ‚úÖ Simple                     | ‚ùå Complex                        | ‚ö†Ô∏è Learning curve                  | ‚ö†Ô∏è Requires Protobuf & tools     |
| *Versioning*      | URI-based (e.g. `/v1/users`) | SOAP actions                     | No versioning, evolves with schema | API evolution via Protobuf       |
| *Performance*     | Good                         | Slower due to XML                | Good (reduces overfetching)        | Excellent (binary, multiplexed)  |
| *Tooling Support* | ‚úÖ Strong                     | ‚úÖ Mature                         | ‚úÖ Good (Apollo, Relay)             | ‚úÖ Good (esp. for microservices)  |
| *Best For*        | CRUD APIs, Web Apps          | Enterprise apps, Banking systems | Mobile apps, complex queries       | Microservices, real-time systems |
| *Contract/Schema* | Optional (OpenAPI/Swagger)   | Required (WSDL)                  | Required (GraphQL Schema)          | Required (Proto files)           |

###### üßæHttp Status Codes
![[HTTP Status Codes.png|950]]

---
##### @RestController
Spring 4.0 introduced the @RestController annotation in order to simplify the creation of RESTful web services. 

It‚Äôs a convenient annotation that <mark style="background: #FF6699;">combines @Controller and @ResponseBody, which eliminates the need to annotate every request handling method of the controller class with the @ResponseBody annotation</mark>.

Here is the example using @Controller - 
```Java
@Controller 
@RequestMapping("books") 
public class SimpleBookController { 
	@GetMapping("/{id}") 
	public @ResponseBody Book getBook(@PathVariable int id) {...}
	
	//or you can also do this
	
	@GetMapping("/{id}") 
	@ResponseBody
	public Book getBook(@PathVariable int id) {...}
}
```

---
##### üì•@ResponseBody and @RequestBody
@ResonseBody
- **Purpose**: Tells Spring to serialize the return value of a method directly into the HTTP response body.
- **Common Usage**: For REST endpoints that return JSON/XML instead of a view (like a Thymeleaf page).

@RequestBody
- **Purpose**: Binds the HTTP request body to a Java object.
- **Common Usage**: In `POST`, `PUT`, or `PATCH` methods where data is sent in the request body (e.g., JSON).
- **How it works**: Spring uses implementation of`HttpMessageConverter` (like `MappingJackson2HttpMessageConverter` for JSON) to convert the incoming JSON/XML into a Java object.

> [!tldr]+ TLDR
> The¬†`@ResponseBody`¬†annotation enables automatic serialization of the return object into the¬†`HttpResponse`
> The `@RequestBody` annotation  enables automatic deserialization of the incoming`HttpRequest` body to a domain object

---
##### üîó@PathVariable
 > The @PathVariable annotation can be used to handle template variables in the request URI mapping and bind them to method parameters in a controller.

You can omit the name if the method parameter name matches the path variable:
```Java
@GetMapping("/users/{id}")
public ResponseEntity<User> getUserById(@PathVariable Long id) {...}

//OR you can always do this, just to be safe- 

@GetMapping("/users/{id}")
public ResponseEntity<User> getUserById(@PathVariable("id") Long userId) {...}
```
---
##### üìÑ @RequestParam
> The `@RequestParam` annotation is used to extract **query parameters**, **form data**, or **URL parameters** from an HTTP request and **bind** **them** to method arguments.

Just like @PathVariable, you can omit the name if the method parameter name matches the request param
```Java
@GetMapping("/api/foos")    //url :- http://localhost:8080/api/foos?id=abc
public String getFoos(@RequestParam String id) {...}

//OR you can always do this, just to be safe- 

@GetMapping("/api/foos")    //url :- http://localhost:8080/api/foos?id=abc
public String getFoos(@RequestParam("id") String userId) {...}
```

If in the above request, the request parameter is not provided, then the controller will throw `400-Bad Request`

<mark style="background: #33EE99;">We can configure our @RequestParam to be optional, though, with the required attribute OR use Optional AND/OR provide a default value with `defaultValue` attribute</mark> :
```Java
@GetMapping("/api/foos")    //url :- http://localhost:8080/api/foos?id=abc
public String getFoos(@RequestParam("id", required=false) String userId) {...}

@GetMapping("/api/foos")    //url :- http://localhost:8080/api/foos?id=abc
public String getFoos(@RequestParam Optional<String> id){...}

@GetMapping("/api/foos")    //url :- http://localhost:8080/api/foos?id=abc
public String getFoos(@RequestParam("id", defaultValue="xyz") String userId) {...}
```
###### üÜö@PathVariable

| Feature             | `@RequestParam`          | `@PathVariable`     |
| ------------------- | ------------------------ | ------------------- |
| Location            | Query string / form data | URL path segments   |
| Example URL         | `/users?id=1`            | `/users/1`          |
| Flexible / Optional | ‚úÖ Yes                    | üö´ Usually required |

---
##### üì•@RequestHeader
The @RequestHeader annotation is used to extract values from HTTP headers in an incoming request and bind them to method parameters in a controller.
It allows your Spring controller to read client-sent headers like Authorization, User-Agent, custom headers, etc.

```Java
@GetMapping("/greet")
public String greetUser(@RequestHeader(name = "User-Agent") String userAgent) {...}

@GetMapping("/hello")
public String sayHello(@RequestHeader(name = "X-User", required = false, defaultValue = "Guest") String user) {...}

@GetMapping("/headers")
public String getAllHeaders(@RequestHeader Map<String, String> headers) {...}
```
###### üîê Common Use Cases
- Read tokens: `Authorization: Bearer <token>`
- Handle versioning: `X-API-Version: v1`
- Customize behavior based on headers: `Accept-Language`, `User-Agent`
##### üç™ @CookieValue
The @CookieValue annotation is used to bind the value of an HTTP cookie to a method parameter in a controller.

```Java
@GetMapping("/dashboard")
public String showDashboard(@CookieValue(name="session_id") String sessionId) {...}

@GetMapping("/welcome")
public String welcomeUser(@CookieValue(name="user", required=false, defaultValue="Guest") String user) {...}
```


> [!tip] Cookies are stored in HTTP headers - Why not @RequestHeader?
> A browser sends cookies as  -
> ```vbnet
> GET /home HTTP/1.1
> Host: example.com
> Cookie: session_id=abc123; theme=dark
> ```
> So yes, you could extract the entire Cookie header using: `@RequestHeader("Cookie") String cookieHeader`, but you'd then need to manually parse the string (split by `;`, then use `'='` etc.), which is cumbersome and error-prone.
> `@CookieValue` to conveniently extract individual cookies: `@CookieValue("session_id") String sessionId`

---
##### üìå@RequestMapping
It is used to map HTTP requests to controller methods and/or classes
It can handle all HTTP methods (GET, POST, etc.) and allows customization with attributes like:
- `method` (GET, POST‚Ä¶)
- `path` or `value` (URL like `"api/foo"`)
- `params`, `headers`, `consumes`, `produces`

```Java
@RequestMapping("/api")            //class level mapping
@RestController
public class HelloController{
	@RequestMapping(value = "/hello", method = RequestMethod.GET)        //method level mapping
	public String sayHello() {...}
}
```

> The HTTP¬†method¬†parameter has¬†**no default.**¬†So, if we don‚Äôt specify a value, it‚Äôs going to map to any HTTP request.
###### ‚ú®Specialized Annotations
| Annotation       | Equivalent `@RequestMapping`                     |
| ---------------- | ------------------------------------------------ |
| `@GetMapping`    | `@RequestMapping(method = RequestMethod.GET)`    |
| `@PostMapping`   | `@RequestMapping(method = RequestMethod.POST)`   |
| `@PutMapping`    | `@RequestMapping(method = RequestMethod.PUT)`    |
| `@DeleteMapping` | `@RequestMapping(method = RequestMethod.DELETE)` |
| `@PatchMapping`  | `@RequestMapping(method = RequestMethod.PATCH)`  |
###### üì¨ Using headers in @RequestMapping
The `headers` attribute in @RequestMapping, @GetMapping, etc., allows you to filter requests based on HTTP headers. 
This is useful when you want to process requests differently based on custom headers, Content-Type

```Java
@GetMapping(value = "/secure", headers = "X-Auth-Token=mytoken")
public String secureAccess() {...}      //Only responds if the request has `X-Auth-Token: mytoken`

@PostMapping(value = "/submit", headers = "Content-Type=application/json")
public String submitData(@RequestBody String body) {...}
```

You can also use:
- `!key` ‚Üí header must not be present
- `key!=value` ‚Üí header must be present but not equal to this value

> [!example] Tip
> Instead of using `headers`, if you only want to specify accepted or expected content types, prefer:
> - `consumes = "application/json"`
> - `produces = "application/json"`

---
##### üîπ `ResponseEntity<?>`
`ResponseEntity<?>` is a **generic** type in Spring used to represent the **entire HTTP response**, including:
- **Status code** (e.g., 200 OK, 404 Not Found)
- **Headers**
- **Body** (data payload)

##### üì° @ResponseStatus
 It is used in a controller method or exception class to <mark style="background: #19B5FF;">set the HTTP status code without needing to wrap the response in a `ResponseEntity`</mark>.

Example - On a controller method
```Java
@PostMapping("/users")
@ResponseStatus(HttpStatus.CREATED) // Returns 201 Created
public User createUser(@RequestBody User user) {...}   //avoids- ResponseEntity<>(user, HttpStatus.CREATED);
```

Example - On an exception class
```Java
@ResponseStatus(HttpStatus.NOT_FOUND)
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String msg) {
        super(msg);
    }
}
```
##### üß™@RestControllerAdvice or @ControllerAdvice
With `@RestControllerAdvice` + `@ExceptionHandler`, you can define methods that will be triggered when specific exceptions are thrown in any controller.
Here is an example,  when that exception is thrown from any class - 
```java
throw new UserNotFoundException("User with ID not found");
``` 

Spring will catch it and route to below class  where we have declared a Global Exception Handler that handle User not found exceptions
```Java
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(UserNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public Map<String, String> handleUserNotFound(UserNotFoundException ex) {
        Map<String, String> error = new HashMap<>();
        error.put("error", ex.getMessage());
        return error;
    }
}
```

> [!tip]+
> @RestControllerAdvice is for @RestController and @ControllerAdvice is for @Controller
> Hence the difference between @RestControllerAdvice and @ControllerAdvice is also @ResponseBody

---
##### üî∑JPA Annotations
- **`@Entity`** ‚Äì Marks a class as a JPA entity (i.e., maps to a database table).
- **`@Table`** ‚Äì Specifies the table name in the DB; optional if it matches the class name.
- **`@Id`** ‚Äì Marks a field as the primary key.
- **`@GeneratedValue`** ‚Äì Specifies how the primary key is generated (e.g., AUTO, IDENTITY).
- **`@Column`** ‚Äì Maps a field to a DB column; can customize name, length, nullable, etc.
###### Embedded Ids
```Java
@Embeddable
public class Address {
    private String city;
    private String country;
}

@Entity
public class Customer {
    @Id
    private Long id;

    @Embedded
    private Address address;
}
```
##### üî∂ Bean Validation Annotations
Please read this GFG article - [JSR Annotations](https://www.geeksforgeeks.org/springboot/spring-bean-validation-jsr-303-annotations/)
- **`@NotNull`** ‚Äì Field must not be `null` (e.g., required for DB or logic).
- **`@NotBlank`** ‚Äì Field must not be `null` **and** not empty (`""`); for Strings only.
- **`@Size`** ‚Äì Defines min and max size (e.g., string length or collection size).
- **`@Min` / `@Max`** ‚Äì Specifies the minimum or maximum value allowed (numeric fields).

```Java
public class UserAccount { 
	@NotNull 
	@Size(min = 4, max = 15) 
	private String password; 
	
	@NotBlank 
	private String name;
	
	@Min(value = 18, message = "Age should not be less than 18") 
	private int age;
}
```

##### üì¶Data Transfer Object
A plain Java object used to transfer data between layers and often contains subset of entity data or aggregated fields.
> A POJO is a class with **only** fields, constructor and/or getter-setters. It should not contain any business logic methods

> [!tip] Entity vs DTO
> Sometimes confused with entity, but entity is always a class mapped to a database table using JPA (@Entity annotation). 
> An entity in JPA represents a table stored in a database. Every instance of an entity represents a row in the table.
> A DTO keeps the API safe from exposing internal database schema.


###### üîÑ Mapping Between Entity and DTO
Libraries like <mark style="background: #33EE99;"><mark style="background: #BBFABBA6;">`MapStruct` and `ModelMapper` help automate the conversion between Entities and DTOs</mark></mark>
###### Map Struct
- Annotation-based
- Generates efficient, type-safe mapping code at *compile time*
- `mapstruct` dependency is required in pom.xml
- Very fast and explicit
- Requires you to define mapper interfaces
- Example - 
```Java
@Mapper
public interface UserMapper {
    UserDTO toDto(User user);
    User toEntity(UserDTO dto);
}

//To use the mapper - 

public class UserService{
	@Autowired
	private UserMapper userMapper;

	public void saveUser(UserDTO userDTO){
		User user = userMapper.toEntity(userDTO); 
		//similarily,we can - userMapper.toDTO(user);
		repo.save(user);
	}
}
```
###### Model Mapper
- Instance/Object based
- Uses reflection to map fields dynamically at *runtime*
- Requires `modelmapper` dependency in pom.xml
- Very quick to set up, less code.
- Not type-safe and a bit slower due to reflection.
- Great for small/medium projects or quick prototyping.
```Java
ModelMapper mapper = new ModelMapper();
UserDTO dto = mapper.map(user, UserDTO.class);
```

| Feature         | **MapStruct**             | **ModelMapper**            |
| --------------- | ------------------------- | -------------------------- |
| Mapping style   | Compile-time (faster)     | Runtime (reflection-based) |
| Performance     | ‚úÖ High                    | ‚ö†Ô∏è Slower                  |
| Type-safety     | ‚úÖ Yes                     | ‚ùå No                       |
| Setup           | ‚ö†Ô∏è Slightly more setup    | ‚úÖ Plug-and-play            |
| Custom mappings | ‚úÖ Cleaner via annotations | ‚úÖ Fluent API               |
### Connecting to a Database
Spring Boot makes database connectivity simple by handling most configurations automatically. 
You just need to provide the database details, and Spring Boot sets up the `DataSource`,  `ConnectionPool`, `EntityManagerFactory`, and `TransactionManager` behind the scenes
> This is actually done by `@EnableAutoConfiguration`. This annotation reads the `.properties` or `.yaml`file and using them automatically configures them
#### Steps Required
1. Adding the specific driver dependency
2. Adding Data JPA dependency
3. Setting up .properties file
#### Core Properties required in .properties 
```properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=secret
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
```

**`spring.datasource.url`** ‚Üí JDBC connection string (depends on DB vendor)
**`spring.datasource.username`** ‚Üí DB username
**`spring.datasource.password`** ‚Üí DB password
**`spring.datasource.driver-class-name`** ‚Üí Driver class (optional in Spring Boot 2+, usually auto-detected)
#### JPA Properties
```properties
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect
```
**`spring.jpa.show-sql`** ‚Üí Logs SQL statements to console.

**`spring.jpa.database-platform`** ‚Üí Hibernate dialect (often auto-detected)
- It defines how Hibernate talks to your database. 
- Hibernate needs to generate SQL that works with your database.
- If you don‚Äôt set this property, Spring Boot tries to auto-detect it from the JDBC URL
-  It is often optional, but setting it explicitly avoids ambiguity and ensures correct SQL generation

**`spring.jpa.hibernate.ddl-auto`** options:
- create ‚Üí Hibernate drops and recreates the entire schema on each application startup. 
- create-drop ‚Üí Hibernate creates the schema on startup and drops it when the `SessionFactory` is closed (e.g., when the application shuts down). This is also primarily for testing
- update ‚Üí Hibernate attempts to update the schema by adding new columns or tables based on your entity changes, but it will not drop existing tables or columns
- validate ‚Üí Hibernate validates the existing schema against your entity mappings. It throws an error if there are discrepancies but makes no changes
- none ‚Üí Hibernate performs no DDL operations. This is generally recommended for production environments where schema changes are managed by dedicated migration tools like Flyway or Liquibase, or manually by DBAs

> [!tip]+ Difference between create and create-drop
> create:
> Drops and recreates the schema on startup. Data is lost on restart. Schema persists after shutdown until the next startup.
> create-drop:
> Drops and recreates the schema on startup, and also drops the schema on shutdown. Data is lost on restart and on shutdown.
#### Connection Pooling (HikariCP by default)
Spring Boot uses `HikariCP` as the default connection pool.
```properties
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
```
#### Test Database
```properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.h2.console.enabled=true
```
#### Profiles for Different Environments
We can set separate configs in .properties for dev, test, prod and then activate them with - [[Spring Boot Annotation#üìåSpring Application Properties]]
```properties
spring.profiles.active=prod
```

### Flyway
Dependency:
```xml
<dependency>
  <groupId>org.flywaydb</groupId>
  <artifactId>flyway-core</artifactId>
</dependency>
```

.properties/.yaml:
```yaml
flyway:
    locations: classpath:db/migration
    validate-on-migrate: true
```
##### Flyway does - 
- Database schema versioning & migrations: You express each schema change as a migration (usually a SQL file)
- Deterministic deployments: Every environment (dev ‚Üí prod) runs the same ordered set of migrations
- Auditability: Flyway records what ran, when, and with which checksum in a special table (`flyway_schema_history`)
- Safety checks: It validates checksums so accidental edits to past migrations are caught early
##### Concepts
1. Versioned migrations (`V1__, V2__, ‚Ä¶`)
	- Ordered, one-time scripts that evolve the schema (e.g., create/alter tables)
2. Repeatable migrations (`R__name.sql`)
	- Re-applied when their content changes (good for views, functions, stored procedures)
3. Locations
	- Where Flyway looks for migrations. Spring Boot default: `classpath:db/migration`
4. Schema history table
	- Flyway writes an entry per migration with version, description, checksum, and execution state.
5. Validation & checksum
	- On startup, Flyway can validate already-applied migrations to ensure no content drift
6. Baseline
	- If you start using Flyway on an existing database, you can mark the current state as a baseline to avoid re-running old scripts
7. Repair
	- Recalculates checksums and cleans up failed entries in the history table (use with care)
8. Forward-only mindset
	- Migrations should be append-only. If you need to ‚Äúundo,‚Äù write another migration that reverses the change
##### Useful Flyway Commands 
*`mvn flyway:migrate`*
- Applies all pending migrations to bring your database up to date
- Looks at the `flyway_schema_history` table, checks what‚Äôs already been applied, then runs the next SQL/Java migrations in version order

*`mvn flyway:info`*
- Shows the state of the database. Lists all migrations (both applied and pending) along with status, version, description, and checksum
- Use it to check whether your database is up-to-date or to debug when you suspect a migration didn‚Äôt run

*`mvn flyway:validate`*
- Validates that applied migrations in the database match the migration files on disk (e.g., same checksum).
- Catches cases where someone accidentally edited an old migration file (which is a big no-no)
- Useful to run before running `migrate` in CI/CD pipelines

*`mvn flyway:repair`*
- Repairs the `flyway_schema_history` table by:
	- Recalculating and fixing checksums of applied migrations (useful if you absolutely had to edit an old migration ‚Äî though generally discouraged) 
	- Removing failed migration entries so you can re-run them.
- Use it only in special circumstances (corruption, checksum mismatch you can‚Äôt avoid) and it‚Äôs a last-resort tool, not part of normal workflow

*`mvn flyway:clean`*
- Drops all objects in the configured schemas (tables, views, procedures, everything)
- Use it in development/test environments where you want to reset to a blank schema and reapply migrations from scratch.
- But **NEVER in production** (and that‚Äôs why there‚Äôs a `clean-disabled` flag in .properties or .yaml which can be set to true)
### Swagger

![[Swagger in Spring Boot]]
### Cross Origin Resource Sharing (CORS)
CORS allows you to explicitly define which cross-domain requests are authorized. So, if your frontend (`http://localhost:3000`) tries to call your backend (`http://localhost:8080`), the browser blocks it unless the backend explicitly allows cross-origin requests

In Spring Boot, you can add **`@CrossOrigin(origins = "http://localhost:3000")`** to a controller class or controller method to specify that endpoint/s is accessible by which domains/origins

```java
@RestController
@RequestMapping("/api")
public class UserController {

    @CrossOrigin(origins = "http://localhost:3000")  // origins = "*" for all
    @GetMapping("/users")
    public List<User> getUsers() {
        return userService.getAll();
    }
}

//Also, you can globally set the CORS config

@Configuration
public class WebConfig implements WebMvcConfigurer {      //WebMvcConfigurer is used for global CORS
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("http://localhost:3000")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
```

%% 
TODO 
- `@CrossOrigin` for CORS
%%