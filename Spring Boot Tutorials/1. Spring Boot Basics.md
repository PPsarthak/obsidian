---
status: It continues...
last-reviewed: 2025-08-15
tags:
  - spring-boot
  - basics
---

#placement-preparation #spring-boot #basics

#### üó£Ô∏èWhat is Spring Boot?
Spring Boot is built on top of Spring framework and simplifies the development of Spring applications
- Comes with an embedded server (like Tomcat), so you can run apps with a simple `main()` method
##### üß±What is a framework?
A framework consists of libraries and is used to provide abstraction for developing applications. 
Think of it as a template, allowing developers to focus on the application's logic rather than low-level details or configuration of project

---
#### üÜö Spring vs Spring Boot

| Feature           | Spring Framework                                  | Spring Boot                                        |
| ----------------- | ------------------------------------------------- | -------------------------------------------------- |
| Setup             | Requires manual configuration (XML/Java)          | Provides auto-configuration                        |
| Server            | Needs external server (e.g., Tomcat)              | Comes with embedded servers (Tomcat, Jetty)        |
| Project Structure | Requires setting up dependencies manually         | Uses opinionated starter dependencies              |
| Goal              | Provides comprehensive features for building apps | Simplifies Spring app development with quick setup |
| Learning Curve    | Steeper due to more boilerplate and config        | Easier and faster to get started                   |

---
#### ‚úÖ Features of Spring Boot
- **Auto-Configuration**: Automatically configures Spring beans based on `classpath` contents.
- **Starter Dependencies**: Predefined sets of dependencies for common use-cases (`spring-boot-starter-web`, `starter-data-jpa`, etc.).
- **Embedded Servers**: Comes with built-in Tomcat, Jetty, or Undertow ‚Äì no need to deploy `.war` externally.
- **Production-Ready Features**: Built-in health checks, metrics, monitoring via Spring Boot Actuator.
- **Minimal Configuration**: Reduces need for XML/Java config ‚Äì uses sensible defaults.

> [!tip]+ Remember this!
> The Spring Data, Spring Security, DI, IOC, AOP, MVC, etc. are already present in Spring (core Spring, not Spring Boot).  
> <mark style="background: #19B5FF;">Spring Boot = Core Spring + Auto Configuration + Embedded Server + Starter Dependency + Reduced Boilerplate Code</mark>

---
#### üèóÔ∏èSpring Boot Architecture
Spring Boot is built on top of Spring Framework which itself is built on top of Servlets
![[Placement Preparation - Spring Boot Architecture.png|550]]

---
#### üö¶Spring Boot Application Startup Flow
- `main()` method starts the application via `SpringApplication.run()`
- Component Scan Begins: 
	- `@ComponentScan`: Scans current and sub-packages for Spring components (`@Service`, `@Repository`, etc.)
	- `@Configuration`: Marks the class as a config source 
	- `@EnableAutoConfiguration`: Triggers Spring Boot‚Äôs auto-config
- Spring Boot creates an **`ApplicationContext`** (IoC container) to manage all beans
- Auto configuration starts:
	- Based on the `classpath` and `application.yaml/properties`, Spring Boot auto-configures beans (e.g., DB, web server, etc.)
- Embedded Server starts
- Beans are created and injected via DI
- Any methods marked with `@PostConstruct` are run after bean initialization.
- `CommandLineRunner` or `ApplicationRunner` beans (if present) run.
- App is now fully started

---
##### üè∑Ô∏è`@SpringBootApplication` Annotation
> `@SpringBootApplication`: Combines `@Configuration`, `@EnableAutoConfiguration`, and `@ComponentScan`.

> [!tip] Breakdown of Combined Annotations
> **`@Configuration`**:
> 	- Marks the class as a source of bean definitions
> 	- Works like XML or Java config classes in Core Spring (Beans were defined in `applicationContext.xml` or similar files using `<bean>` tags in Core Spring)
> 	
> **`@EnableAutoConfiguration`**:
> 	- Enables Spring Boot's Auto Config mechanism
> 	- Automatically configures beans based on the classpath and defined properties. Example:
> 		-  - If¬†`spring-boot-starter-web`¬†is present, configures DispatcherServlet, Tomcat, etc. 
> 		-  -If `mysql-connector-java` is present (with correct `application.yaml` file), then it will  auto-configure a `DataSource` bean
> 	
> **`@ComponentScan`**
> 	- Tells Spring where to look for annotated components (`@Component`, `@Service`, `@Repository`, etc.).
> 	- By default, it scans the package of the class annotated with `@SpringBootApplication` and all sub-packages.
> 	- Developers may customize it to only scan specified packages which - reduce startup time/prevent unwanted beans

---
#### üß©Profiles
A profile is a way to group and activate specific configurations or bean definitions based on the environment in which the application is running (e.g., dev, test, prod, local, staging, etc.).

> Profiles let you <mark style="background: #ADCCFFA6;">define environment-specific configurations</mark> (e.g., dev, prod, test).
> It allows you to **customize behavior** or **resources** without changing code when moving between environments.

###### üöÄ Example use-cases:
- üîÑSwitch DB configs:  Use H2 in `dev`, MySQL in `prod`
- üêûDebugging Tools:  Enable Swagger/ Actuator only in `dev`
- üîíSecurity:  Disable auth in `local`, enable in `prod`

###### üìÑFile Naming Convention:
- `application.yml` ‚Üí default config
- `application-dev.yml` ‚Üí config for `dev` profile
- `application-prod.yml` ‚Üí config for `prod` profile

 To activate a given profile, you can
- Set the properties as : `spring.profiles.active: dev`
- Or via command-line :  `--spring.profiles.active=dev`

> [!example]+ Conditional loading of beans using @Profile
> ```Java
> @Bean
> @Profile("dev")
> public DataSource devDataSource() { ... }
> ```
> Now the DataSource bean will only created in "dev" profile

> Always define a default config in `application.yml` for common/shared settings.
> You can group profiles too, in the following format - 
> `spring.profiles.group.staging = [dev, test]` # creating the group called "staging"
> `spring.profiles.active = staging`

---
#### üåê External Configuration

Spring Boot follows a **priority order** (highest wins):
1. Command-line args: `--server.port=9090`
2. OS environment variables: `SERVER_PORT=9090`
3. `application.yaml or application.properties`
4. Default values in code

***@Value and @ConfigurationProperties***
The properties set in `application.yaml or application.properties` can be accessed using `@Value` 
```Java
@Value("${server.port:9090}")
private int port;
```
<mark style="background: #BBFABBA6;">The ':' is used to set the default value. So here, if `server.port` does not exists in properties file, then 9090 is the default value</mark>

@ConfigurationProperties is used to bind full config objects
> Requires `@EnableConfigurationProperties` in some Spring versions
```java
@Component
@ConfigurationProperties(prefix = "app")
public class AppConfig {
  private String name = "MyApp";  //MyApp is the default value if name property does not exists
  private String version = "1.0"; //1.0 is the default value if version property does not exists
}
```

The above class will automatically pick these application properties (the ones starting with "app"):
```yaml
app:
  name: MyApp
  version: 1.0
```

### üîÑ Inversion Control, Dependency Injection and Application Context
IoC is a design principle where the <mark style="background: #FFB86CA6;">control of object creation and lifecycle is inverted</mark> ‚Äî it is handled by a framework (like Spring), not by the developer.

###### üì¶IoC Container - 
- Core component in Spring that <mark style="background: #FFB8EBA6;">handles object creation, wiring, configuration, and lifecycle</mark>
- Implemented as `ApplicationContext`
- Reads metadata (annotations/config/XML), creates beans, and manages them

###### ü§îWhy IoC?
- ‚úÇÔ∏è Reduces tight coupling between classes
- üîÑ Makes code more testable and maintainable
- ‚ôªÔ∏è Promotes reusability via configuration, not hardcoding
- üß© Enables plug-and-play architecture

##### üì•Dependency Injection
Dependency Injection is a design pattern where an <mark style="background: #BBFABBA6;">object‚Äôs dependencies are injected instead of the object creating them itself.</mark>

<mark style="background: #FF5582A6;">Dependency Injection is responsible for satisfying the Dependency Inversion of SOLID Principle</mark>

| Concept            | Inversion of Control (IoC)                                      | Dependency Injection (DI)                                 |
| ------------------ | --------------------------------------------------------------- | --------------------------------------------------------- |
| Definition         | A broader principle: delegates object management to a container | A specific way to implement IoC by injecting dependencies |
| Scope              | General control inversion in program flow                       | One technique to implement IoC                            |
| Who controls what? | Framework controls object lifecycle                             | Framework injects required dependencies into the object   |
| Example            | Spring manages all beans in the context                         | Injecting a `UserRepository` into `UserService`           |
> DI is also a principle that says the dependencies (objects a class needs) should be injected by the container rather than created manually.

Spring supports 3 types of DI:
1. Constructor Injection  <mark style="background: #CACFD9A6;">‚úÖRecommended</mark>
2. Setter Injection  
3. Field Injection (via `@Autowired`)

###### üéØWhy is Constructor Injection Recommended?
 Firstly, Field Injection does not support "final" i.e. if we have - 
 ```Java
 @Autowired
 private final UserRepository userRepository = null;
```
then the above null initialization is completely neglected. 
Spring will still create the `userRepository` bean and it will not remain null (This is because <mark style="background: #D2B3FFA6;">Spring Reflection</mark> is used to create these beans - which completely ignores the final keyword) 

Setter Injection allows you to set the dependencies at any time after object creation. 
- Advantage: using setter we can change the dependency anytime or better yet, not even set the dependency if it is optional
- Disadvantage: dependencies cannot be set as final because we have a setter

Constructor Injection on the other hand, supports everything - 
- You can set the mandatory fields while creating bean at runtime
- Supports final as expected, dependency cannot be changed after initialized in the constructor

> [!summary]
> |Injection Type|Required?|Testability|Immutability|Clean Design|When to Use|
> |---|---|---|---|---|---|
> |**Constructor**|‚úÖ Yes|‚úÖ Best|‚úÖ Yes|‚úÖ Best|Recommended (always if possible)|
> |**Setter**|‚ùå No|üëç Good|‚ùå No|‚ö†Ô∏è Okay|Optional dependencies|
> |**Field**|‚ùå No|‚ùå Poor|‚ùå No|‚ùå Weak|Small prototypes or quick PoCs|
>
> 

##### üß†Application Context
`ApplicationContext` is the **central interface** in the Spring Framework that represents the **IoC container and DI**.
`ApplicationContext` is where all your Spring beans live, and it manages everything related to them.

> [!abstract] Summary
> In simpler terms, IoC is just a principle that states we should let the framework handle beans. DI is also a principle that states that we should inject dependencies into a class instead of it creating them
> <mark style="background: #ADCCFFA6;">Application Context is actual class that does exists, IoC and DI are no classes - they are theoretical concepts. Application Context implements these principles</mark>

#### üí°@Configuration + @Bean, @Component and Multiple Beans
---
##### üõ†Ô∏è@Configuration
When you annotate a class with `@Configuration`, Spring treats it as a source of bean definitions. 
This means that Spring will scan the class for methods annotated with `@Bean` and register those methods‚Äô return types as beans in the Spring application context.

```Java
@Configuration
public class AppConfig {
    @Bean
    public Repo repo() { return new Repo(); }
}
public class Repo{...}
```

> If you use `@Bean` methods **without `@Configuration`**, they still work ‚Äî but Spring won‚Äôt proxy them. So multiple calls may create **multiple instances**, breaking singleton behavior.
> Always use `@Configuration` for proper lifecycle management.

> [!todo] ###### Full Mode vs Lite Mode of @Configuration
> Starting from Spring 5.2, the `proxyBeanMethods`attribute was introduced in @Configuration. This attribute controls whether Spring uses proxies to manage @Bean method calls within the same class
> 
> `@Configuration(proxyBeanMethods = true)` <mark style="background: #CACFD9A6;">Default</mark>
> - Ensures that every `@Bean` method call returns the same singleton instance.
> 
> `@Configuration(proxyBeanMethods = false)`
> - No proxy; `@Bean` methods behave like regular methods and return new instance on each call

##### üß±@Component
Marks a class as a Spring-managed bean and spring will detect it during component scanning and register it in the `ApplicationContext`.

> [!tip]+ Different from @Configuration + @Bean
> - @Configuration indicates that the class contains one or more @Bean methods and it is a Java-based replacement for XML config. @Bean define each individual bean
> - Bean Registration is at method level here, whereas in @Component, it is at class level
> - You will generally use @Component for classes that you write, whereas you will use @Bean to return third-party (already created/existing) beans
> - Also, these beans are not discovered by component scanning ‚Äî they are declared explicitly.

##### üßë‚Äçüíª@Service, @Repository, @Controller
In Spring, all of these annotations are used to mark a class as a Spring-managed bean, but they have semantic meaning and may carry additional behavioral metadata.

| Annotation        | Role                              | Layer              | Special Behavior                                                                                     |
| ----------------- | --------------------------------- | ------------------ | ---------------------------------------------------------------------------------------------------- |
| `@Component`      | Generic bean                      | Any                | None                                                                                                 |
| `@Service`        | Business logic                    | Service Layer      | Just semantic meaning                                                                                |
| `@Repository`     | DB interaction                    | Persistence Layer  | Exception translation (JPA support)                                                                  |
| `@Controller`     | Web endpoint                      | Presentation Layer | Web request mapping + view rendering                                                                 |
| `@RestController` | Specialized to create RESTful API | Presentation Layer | Automatically serializes returned objects (usually to JSON) and sends them in the HTTP response body |

##### üéØMultiple Beans - @Qualifier and @Primary
Say we have multiple beans returning Vehicle (interface/super class of Car and Bike)
```Java
@Bean
public Vehicle car(){ return new Car(); }
@Bean
public Vehicle bike(){ return new Bike(); }
@Autowired
private Vehicle vehicle; //throws NoUniqueBeanDefinitionException
```

@Primary
Tells Spring: <mark style="background: #BBFABBA6;">This bean should be preferred by default when multiple candidates exist</mark>
 ```Java
@Bean
@Primary   //now this bean is returned by default
public Vehicle car() { return new Car(); }
```

 @Qualifier
 Qualifier is used to name the bean. While injecting the dependency, we can simply use the name to resolve the beans.
 <mark style="background: #BBFABBA6;">Generally, the we can pass the exact method name inside the qualifier annotation to resolve the confusion. Or, we can also give it a custom name</mark>
 
```Java
@Bean("fastBike") 
public Vehicle bike() { return new Bike(); }

//or if you have a @Component class instead of @Bean method
@Component
@Qualifier("fastBike")
public class Bike{...}

//And this is how you get it
public class VehicleService{
	@Autowired
	@Qualifier("fastBike")
	private Vehicle vehicle;
}
```

#### ü´òBean Lifecycle
1. Instantiation:
	- Spring creates an instance of the bean using the constructor
2. Dependencies Injection:
	- Dependencies are injected after constructing the object  via `Field/Constructor/Setter Injection`
3. Custom `init()`method or`@PreConstruct`method or`afterPropertiesSet()` from `InitializingBean` interface
4. Bean is ready
5. Custom`destroyMethod()`method or `@PreDestroy` method or`destroy()`from`DisposableBean`interface

> [!info]+ Custom `init()` method
> ```Java
> @Bean(initMethod = "customInit", destroyMethod = "customDestroyMethod")
> public MyBean myBean() { ... }
> 
> public void customInit() { ... }
> 
> public void customDestroyMethod() { ... }
> ```

> [!question]+ ‚ôªÔ∏è@PreConstruct and @PreDestroy
> These annotations define lifecycle methods that are automatically called before and after a Spring bean‚Äôs lifecycle.
> `@PostConstruct` - Runs immediately after the bean is created and dependencies are injected.
> `@PreDestroy` - Called just before the bean is destroyed, typically on application shutdown.
> > You can **only have one `@PostConstruct` and one `@PreDestroy`** per bean.

###### ‚úèÔ∏èA more detailed flow of lifecycle
![[Placement Preparation - Spring Bean Life Cycle.png|550]]

> [!tip]+ @Lazy Annotation
> The `@Lazy` annotation is used to **delay /skip the creation of a Spring bean** until it is **actually needed** (or create the bean **only when it's first requested**), rather than during application startup.
>  ```Java
> @Component
> @Lazy  //you can either use it at declaration
> public class HeavyService {...}
>   
>  @Autowired
> @Lazy  //or at injection point
> private HeavyService heavyService;
> ```
> By default, Spring eagerly creates beans at startup, which may:
> 	 - Increase startup time
> 	 - Initialize unnecessary beans
> 	 - Waste resources for rarely-used components
>  
> It is also useful to handle circular dependency issues

---
#### üå± Spring Bean Scopes
The scope of a bean defines **the life cycle**, **how many instances** of that bean Spring should create and **visibility of that bean** in the contexts we use it.
###### üéóÔ∏èTypes of Bean Scopes
1. Singleton: <mark style="background: #CACFD9A6;">This is the default scope, if nothing is specified</mark>
	- The container creates only 1 instance of the bean and returns the same bean for all requests. If modification is made to that bean, it is reflected in all references
2. Prototype:
	- The container creates new instances every time
	- Useful when you want a stateful object per usage (e.g., UI form models, user sessions).
> *The below ones are only available in a **Spring Web Application Context**.*
3. Application(Web-only): 
	-  The container creates the bean instance for the lifecycle of a `ServletContext` (broader than singleton)
	- Think of it as a singleton shared across the entire app context (not just Spring).
4. Request (Web-only):
	- The container creates a bean instance for a single HTTP request
	- Perfect for storing request-specific data like `HttpServletRequest`-scoped beans.
5. Session (Web-only):
	- The container creates a new bean instance for each HTTP session
	- Lives as long as the user‚Äôs session is active and hence is used to manage user sessions.
6. Web socket (Web-only):
	- The container creates only 1 bean per WebSocket session
	- Used for real-time messaging apps like chat apps

> [!tip]+ @Scope 
> `@Scope` Annotation is used on `@Component` or `@Bean` definitions to control bean lifecycle.
> Example:
> - `@Scope("singleton")` or `@Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON)`
> - For Web-only beans, we need the proxyMode attribute.
> - The proxyMode attribute is necessary because at the moment of the instantiation of the web application context, there is no active request. Spring creates a proxy to be injected as a dependency, and instantiates the target bean when it is needed in a request.


---


